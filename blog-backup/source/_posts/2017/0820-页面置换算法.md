---
title: 页面置换算法
categories: 笔记
date: 2017-08-20 19:17:54
updated:
tags:
description: 内存页面置换算法
---

阅读现在操作系统页面置换算法笔记。因为物理内存有限，也即页框有限，当发生缺页中断时，且页框满时，操作系统必须在内存中选择一个页面将其患处内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘已更新该页面在磁盘上的副本；如果该页面没有被修改过，那么直接用调入的页面覆盖掉被淘汰的页面即可。

<!-- TOC -->

- [1. 最优页面置换算法](#1-最优页面置换算法)
- [2. 最近未使用页面置换算法(NRU: Not Recently Used)](#2-最近未使用页面置换算法nru-not-recently-used)
- [3. 先进先出页面置换算法(FIFO)](#3-先进先出页面置换算法fifo)
- [4. 第二次机会页面置换算法](#4-第二次机会页面置换算法)
- [5. 时钟页面置换算法](#5-时钟页面置换算法)
- [6. 最近最少使用页面置换算法(LRU)](#6-最近最少使用页面置换算法lru)
- [7. 最不常用算法(NFU:Not Frequently Used)](#7-最不常用算法nfunot-frequently-used)
- [8. 老化算法](#8-老化算法)
- [9. 工作集页面置换算法](#9-工作集页面置换算法)
- [10. 工作集时钟页面置换算法](#10-工作集时钟页面置换算法)

<!-- /TOC -->
## 1. 最优页面置换算法

- 算法描述：在缺页中断发生时，有些页面在内存中，其中某个页面将很快被访问，而其他页面可能要10或1000条指令后才会被访问，那么优先将最后被访问的页面置换出去。
- 缺点：无法实现，因为不知道某个页面会在什么时候被访问
- 优点：最优，可以通过首先在仿真程序上运行，跟踪记录页面访问情况，在第二次运行时使用第一次运行收集的信息实现该算法，然后可以对其他实现的算法的性能比较

## 2. 最近未使用页面置换算法(NRU: Not Recently Used)

- 假设条件：页表项中每个页面的访问一般会有两个状态位，当页面被读写时设置R位(Reference)，被修改时设置M位(Modify)。在最近一个时钟中(一般大约20ms)，淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的干净页面要好。

- 算法描述：可以使用R位和M位来构造一个简单的页面置换算法，当启动一个进程时，它所有页面的两个位都被置为0，R位被定期的清零(例如在每次时钟中断)，用于区别最近没有被访问的页面和被访问的页面，不清除M位是因为在决定页面是否需要写回磁盘时将用到。当发生缺页中断时，操作系统检查所有页面的R位和M位的值，分为四类：

|类编号|R位|M位|描述|
|:---|:---|:---|:---|
|0|0|0|没有被访问，没有被修改|
|1|0|1|没有被访问，被修改|
|2|1|0|被访问，没有被修改|
|3|1|1|被访问，被修改|

一个第3类的页面在它的R位被时钟中断清零后就变成了第1类的页面，NRU算法随机地从类编号最小的非空类中选择一个页面淘汰。
- 优点：易于理解和实现
- 缺点：性能不是最好

## 3. 先进先出页面置换算法(FIFO)

- 算法描述：操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在链表尾，最久的在链表头，当发生缺页中断时，淘汰表头的页面，并把新加入的页面加到表尾。
- 缺点：可能淘汰频繁访问的页面

## 4. 第二次机会页面置换算法

第二次机会算法就是寻找一个最近的时钟间隔以来没有被访问过的页面，如果所有的页面都被访问过了，该算法就退化为FIFO算法。
- 算法描述：在FIFO的基础上，检查最老页面的R位，如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R位置0，并把该页面放到链表的尾端，修改它的装入时间，使它像刚装入内存一样。

## 5. 时钟页面置换算法

第二次机会算法需要经常在链表中移动页面，既降低效率又不是很有必要，更好的办法是将所有页面都保存在一个类似钟面的环形链表中，一个表指针指向最老的页面。
- 算法描述：发生缺页中断时，算法首先检查表指针指向的页面，如果它的R位是0，就淘汰该页面，并把新的页面插入这个位置，然后把表指针指向下一个位置；如果R位是1，就清除R位并把表指针指向下一个位置，重复该过程直到找到一个R位为0的页面。

## 6. 最近最少使用页面置换算法(LRU)

对最优算法的近似基于：在前面几条指令中频繁使用的页面很可能在后面的几条指令中被使用，反过来说，已经很久没有使用的页面很可能在未来较长时间的一段时间内仍然不会被使用。根据这个策略，在缺页中断发生时，置换未使用时间最长的页面。这个策略称为LRU(Least Recently Used)。理论上为了实现需要在内存中维护一个所有页面的列表，最近最多使用的页面在表头，最近最少使用的页面在表尾，困难在于每次访问内存都必须更新整个链表，在链表中找到一个页面移动到表头是很耗时的。

- 硬件实现1：64位计数器，每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。每次访问内存后，将当前的计数器值保存到被访问页面的页表项中。一旦发生缺页中断，操作系统就检查所有页表项的计数器值，找到值最小的一个页面，这个页面就是最近最少使用页面

- 硬件实现2：在一个有`n`个页框的机器中，LRU硬件可以位置一个初值为0的`n x n`的矩阵，访问页框`k`时，硬件先把`k`行的位都置为1，再把`k`列的位都置为0，在任何时刻，二进制数值最小的行就是最近最少使用的。

## 7. 最不常用算法(NFU:Not Frequently Used)

- 算法描述：每个页面与一个软件计数器关联，计数器的初值为0，每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的R位加到它的计数器，发生缺页中断时置换计数器值最小的页面。
- 缺点：不遗忘，例如在一个多次扫描编译器中，第一次扫描中被频繁使用的页面在进入第二次扫描时，其计数器的值可能仍然很高。

## 8. 老化算法
- 算法描述：NFU的基础上，在R位被加进计数器之前，首先将计数器右移一位，其次将R位加到计数器最左端的位，而不是最右端的位。发生缺页中断时，置换计数器至最小的页面。

## 9. 工作集页面置换算法

- 请求调页：进程刚启动时内存中没有页面，在CPU试图取第一条指令时，产生缺页中断，是操作系统装入含有第一条指令的页面，其他访问全局数据和堆栈引起的缺页中断通常紧接着发生。
- 工作集：一个进程当前正在使用的页面的集合
- 工作集模型：当进程休眠后，再次运行时系统提前将该进程的工作集装入内存，以减少缺页中断
- 近似实现：过去`x`秒进程运行中访问过的页面，`x`是进程实际占用CPU的时间
- 算法描述：使用硬件来置R位和M位，每个时钟周期有定期的时钟中断会用软件方法来清除R位，每当缺页发生时扫描页表R位，如果为1则更新当前时间到页表项的上次使用时间域，以表示缺页中断发生时该页面正在被使用(不应该被删除)；如果R为0，则该页面可以作为被替换的候选者，接下来计算它的生存时间，然后与`x`作比较，如果它的生存时间大于`x`，那么该页面不在工作集中，可以使用新的页面置换它；扫描继续以更新剩余的表项。然而如果R全为0，且生存时间小于`x`，则选择生存时间最长的一个页面淘汰，如果R全为1，则随机选择一个页面淘汰(尽量选择未修改的干净页面)。

## 10. 工作集时钟页面置换算法

当缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的。有一种改进的算法，它基于时钟算法，并且使用了工作集信息，称为WSClock（工作集时钟）算法（Carr 和Hennessey，1981）。与时钟算法一样，所需的数据结构是一个以页框为元素的循环表。最初，该表是空的。当装入第一个页面后，把它加到该表中。随着更多的页面的加入，它们形成一个环。每个表项包含来自基本工作集算法的上次使用时间，以及R位和M位。

- 算法描述：每次缺页中断时，首先检查指针指向的页面,如果R位被置为1，该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰。然后把该页面的R位置为0，指针指向下一个页面，并重复该算法。
指针指向的页面在R=0时,如果页面的生存时间大于t并且该页面是干净的，它就不在工作集中，并且在磁盘上有一个有效的副本。申请此页框，并把新页面放在其中。另一方面，如果此页面被修改过，就不能立即申请页框，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个旧的且干净的页面可以立即使用。

原则上，所有的页面都有可能因为磁盘I/O在某个时钟周期被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回n个页面。一旦达到该限制，就不允许调度新的写操作。

如果指针经过一圈返回它的起始点会发生什么呢？这里有两种情况：
1) 至少调度了一次写操作。
2) 没有调度过写操作。

对于第一种情况，指针仅仅是不停地移动，寻找一个干净页面。既然已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为干净。置换遇到的第一个干净页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能已经把写操作重排序了。
对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，一个简单的方法就是随便置换一个干净的页面来使用，扫描中需要记录干净页面的位置。如果不存在干净页面，就选定当前页面并把它写回磁盘。


***
